# 🟢 メタ定義: このファイルの責務 (AIエージェント用)
> **AIエージェントへの指示 (Prompt Repetition Strategy):** 
> このファイルは「コードの書き方やスタイル」の正解を定義しています。
> 実装、リファクタリング、コードレビューを行う際に必ず読み込み、スタイルの一貫性を維持してください。

*   **役割:** 命名規則、ディレクトリ構造、コメント規則、スタイリング（Tailwind）の定義。
*   **読むべきタイミング:** ファイル作成、コード記述、リファクタリング時。

---

# Lara-Inertia-Attendance コーディング規約 (Coding Rules)

## 🎨 スタイリングと形式 (Style & Format)

### フロントエンド (React / Tailwind CSS)
*   **Inertia Links:** ページ遷移には必ず Inertia の `<Link>` コンポーネントを使用し、SPA 特有の滑らかな遷移を実現する（`<a>`タグの使用は原則禁止）。
*   **自動整形:** `prettier-plugin-tailwindcss` を適用し、クラス名の並び順を統一する。
*   **スタイリング:** モバイルファーストを徹底し、ユーティリティクラスに直接記述する。`@apply` は原則禁止。
*   **Shadcn/ui 活用:** UI コンポーネントには Shadcn/ui を積極的に採用し、一貫性のあるデザインを構築する。

### バックエンド設計思想 (Thin Controller)
*   **役割分担の徹底:** コントローラーの責務を最小限に抑え、以下のコンポーネントに処理を委譲する。
    *   バリデーション → `FormRequest`
    *   ビジネスロジック・クエリ → `Service`
    *   レスポンス整形 → `JsonResource`
*   **命名規則:** クラス名は `PascalCase`、メソッド・変数は `camelCase`、DBカラムは `snake_case` を厳守。
*   **use 文の積極使用と FQCN の排除:**
    *   コード内でのフルパス指定（例: `\App\Models\User`）は原則禁止。
    *   必ずファイルの冒頭で `use` 文を宣言し、クラス名のみで参照すること。
    *   テストコードにおける `Inertia\Testing\AssertableInertia` は `use Inertia\Testing\AssertableInertia as Assert;` とエイリアスを定義して使用すること。

### 🛠️ 共通ルール
* **論理式の明示的なグルーピング:** 演算子の優先順位に依存せず、括弧 `()` を使用して判定の塊を明示する。
    * **Good:** `return isAxiosError(e) && (e.response !== undefined);`

---

## 📂 ディレクトリ構造と責務 (Directory Structure)

### フロントエンド (`resources/js`)
「役割に応じて大文字・小文字を使い分ける」慣習に従う。
*   **大文字開始 (PascalCase):** React コンポーネント（UI 部品）
    *   `Pages/`: ページコンポーネント（`PageProps` を継承すること）
    *   `Components/`: 再利用可能なパーツ（および `ui/` 配下の Shadcn 部品）
    *   `Layouts/`: 共通レイアウト
*   **小文字開始 (camelCase):** ロジック、型定義、ユーティリティ
    *   `lib/`: 便利関数 (`utils.ts`)、外部ライブラリ設定
    *   `types/`: TypeScript 型定義（`models.d.ts` 等）
    *   `hooks/`: React カスタムフック

### バックエンド (`app`)
*   `Http/Controllers/`: リクエスト受付と `Inertia::render` によるビュー返却。
*   `Http/Requests/`: FormRequest によるバリデーション。
*   `Services/`: ビジネスロジック、複雑なクエリの集約。
*   `Models/`: Eloquent モデル、リレーション、キャスト定義。

---

## 📝 コメント規則 (Commenting Rules)

### 1. 意図を語る (Intent over Implementation)
*   「何をしているか」ではなく、**「なぜ」その処理が必要なのか**（背景や目的）を書く。

### 2. 自己文書化コードの優先 (Refactor First)
*   コメントを書く前に、コード自体を分かりやすくできないか検討する。
*   **説明変数 (Explanatory Variables) の導入:** 複雑な条件式やワンライナーを避け、中間ステップを変数として定義することで、コード自体をロジックの解説にする。
*   **明快なコード (Clear Code) vs 賢すぎるコード (Clever Code):** AI が生成しがちな過度に複雑な処理や型ハックを避け、人間の認知負荷を下げる記述を最優先する。
*   **型エイリアスによる意図の明示:** 複雑な交差型や型ハックが必要な場合は、意味のある名前を付けた型エイリアス（例: `LooseStringAutocomplete<T>`）に切り出し、その Why をコメントする。
*   **変数名・定数化:** マジックナンバーを排除し、意味のある名前をつける。
*   **関数抽出:** 複雑な条件式は、判定意図が伝わる名前の関数に抽出する。

### 3. ゾンビコード（コメントアウトされたコード）の禁止
*   不要になったコードはコメントアウトして残さず、潔く削除する。過去のコードは Git の履歴を信頼すること。

### 4. 外部ソースへのリンクによるトレーサビリティ
*   背景にある業務要件やバグの経緯が複雑な場合、チケット番号（例: US001）や GitHub Issue の URL を明記し、真の「Why」を追跡可能にする。

### 5. 妥協（ワークアラウンド）の理由と解除条件の明記
*   ライブラリのバグ回避など、あえてトリッキーな実装を行う場合は、その理由と**「いつ（どのバージョンで）直すべきか」**を併記する。

### 6. AI エージェントへの文脈提供 (Prompts as Documentation)
*   コメントは未来の AI エージェントへの指示書（プロンプト）としても機能することを意識する。意図が明確であるほど、AI による将来の改修精度が向上する。

### 7. 特殊コメントタグと DocBlocks
*   `TODO:`, `FIXME:`, `WARNING:`, `NOTE:` を適切に使用する。
*   公開メソッドには JSDoc / PHPDoc を記述し、`@param`, `@return` を明確にする。
