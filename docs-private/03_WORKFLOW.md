# 🔴 メタ定義: このファイルの責務 (AIエージェント用)
> **AIエージェントへの指示 (Prompt Repetition Strategy):** 
> このファイルには遵守すべき「厳格なルール」と「手順」が記載されています.
> 内容を**「合計2回」**読み込み、特に「開発ルール」と「プロセス記録ルール」を脳内に強くインデックスしてから作業を開始してください。

*   **役割:** 開発の手順（ロードマップ）、チェックリスト、動作確認ルール、およびGitコミットルールの「執行」定義。
*   **読むべきタイミング:** 新しいタスクに着手する前、作業中の進捗確認、および `git push` を行う直前。
*   **思考の優先順位:** 手順とルールに関して最優先。独自の判断でステップをスキップしてはならない。
*   **含まない情報:** プロジェクトの全体像（01_AGENT_RECOVERY_MANUAL.md を参照）、詳細なテーブル設計（02_RULES_AND_ARCHITECTURE.md を参照）、具体的なコーディング規約（04_CODING_RULES.md, 05_DESIGN_PATTERNS.md, 06_TESTING_GUIDE.md を参照）。

---

# Lara-Inertia-Attendance 開発ワークフロー (Workflow & Checklists)

## 開発ルール (Rules for Execution)

### 動作確認ルール (Verification Standards)
ロードマップの各タスクを「完了」とする前に、**必ず** 以下の検証を行い、正常動作を確証すること。

* **バックエンド (Logic):**
    * **データ整合性:** DBの中身を直接確認し、データが正しく保存・更新されているか。
    * **型定義:** PHPの引数・戻り値の型が、最新のビジネスロジックと一致しているか。
* **フロントエンド (Inertia/UI):**
    * **Props確認:** React Developer Tools等で、コントローラーから期待通りのPropsが渡っているか。
    * **コンソール確認:** ブラウザの開発者ツールで、JavaScriptエラーや不要な警告が出ていないか。
    * **ネットワーク通信:** Networkタブで、Inertiaの XHR リクエストとレスポンスに間違いがないか。
* **エラーハンドリング:**
    * バリデーションエラー時に、適切にエラーメッセージが画面に表示されるか。
    * 「成功パターン」だけでなく、「失敗パターン」でもアプリがクラッシュしないか。

### プロセス記録ルール (Mandatory)
`git push` を実行する直前に、**必ず** 以下の手順をステップ・バイ・ステップで実行すること。

#### ステップ 1: 開発ログの記録
* **対象ファイル:** `docs-private/07_DEV_LOG.md`
* **アクション:** 実装内容、技術的判断、エラーと解決策、実行コマンドを追記する。
* **不可侵ルール:** 過去の記録は、明らかな誤り（事実誤認）がない限り、決して削除や大幅な書き換えを行ってはならない。常に新しい事実を末尾に追記する「追記型」の記録を徹底すること。
* **操作上の厳格な制約 (AIエージェント用):** 
    * 既存記録の消失を防ぐため、更新に `write_file`（全体上書き）を使用してはならない。必ず `replace` による部分追記を行うこと。
    * 追記前には必ず `tail` コマンド等で現在の物理的な末尾を確認し、既存の最終行と正確に接続させること。

#### ステップ 2: 復旧マニュアルの整合性確認
* **対象ファイル:** `docs-private/01_AGENT_RECOVERY_MANUAL.md`
* **アクション:** `07_DEV_LOG.md` の更新内容に基づき、マニュアルを最新化する。

#### ステップ 3: ワークフローの更新
* **対象ファイル:** `docs-private/03_WORKFLOW.md`
* **アクション:** 完了したタスクのチェックボックスをオンにし、「現在進行中のタスク」を更新する。

#### ステップ 4: Gitコミット
* **言語:** 日本語で記述すること。
* **フォーマット:** `プレフィックス: 内容` の形式とする。
* **使用可能なプレフィックス:**
    * `feat`: 新機能の追加
    * `fix`: バグ修正
    * `docs`: ドキュメントのみの変更
    * `style`: コードの動作に影響しない変更（空白、フォーマットなど）
    * `refactor`: バグ修正も機能追加も行わないコード変更
    * `test`: テストの追加・修正
    * `chore`: ビルドプロセス、ツール、ワークフローの変更

#### ステップ 5: リモート反映
* **アクション:** `git push origin <branch_name>` を実行し、変更をリモートリポジトリに確実に反映させる。

---

## 🚀 個人開発向け PR 運用ルール (Personal PR Flow)
開発スピードを維持しつつ、品質と客観性を担保するために以下のフローを原則とする。

### 1. 基本戦略: GitHub Flow
* **ブランチ作成:** `main` から直接コミットせず、機能追加時は `feature/xxx`、修正時は `fix/xxx` ブランチを作成する。
* **PR作成:** 実装が完了したら Pull Request を作成する。
* **例外（直コミットOK）:** README の修正、ドキュメント（`docs-private/`）の更新、メモ書きなどは `main` への直プッシュを許容する。

### 2. 客観的品質の担保
* **セルフレビュー:** PR の差分画面（Files changed）を確認し、不要なデバッグコードや命名の違和感をチェックする（スマホでの確認も推奨）。
* **CIの活用:** PR 作成時に自動実行される GitHub Actions (CI) がパスすることを確認する。
* **意図の記録:** PR 概要欄に「なぜこの実装にしたか」を簡潔に記し、将来の自分へのドキュメントとする。

### 3. マージと整理
* **Squash and merge:** 作業中の細かいコミットを 1 つにまとめ、`main` の履歴を機能単位で綺麗に保つ。
* **ブランチ削除:** マージ後は速やかに作業ブランチを削除する。


### フロントエンドテスト実行戦略 (E2E Testing Strategy)
Playwrightテストの「高速化」と「安定性」を両立するため、以下の手順を推奨する。

1.  **フェーズ1: 高速並列実行**
    *   コマンド: `npx playwright test`
    *   目的: 全体の健全性を素早く確認する。
    *   期待値: ほとんどのテストがパスする。データ競動で一部失敗する可能性がある。
2.  **フェーズ2: 失敗テストの直列検証**
    *   コマンド: `npx playwright test <failed_file_path> --workers=1`
    *   目的: フェーズ1で失敗したテストが「バグ」なのか「競合」なのかを切り分ける。
    *   判断基準:
        *   直列でパスした場合 → **「競合」**（コードは正常。無視して良い、または将来的にテストコード改善）。
        *   直列でも失敗した場合 → **「バグ」**（修正必須）。

---

## 【現在進行中のタスク】 (Active Context)
> AIエージェントは作業中、常にここを更新すること。

**現在のフェーズ:** Phase 6: テストの実装と自動化 (Testing & Automation)
**現在のアクティブタスク:** リファクタリング Phase 2 の検討
**ステータス:** 2026-02-18 リファクタリング Phase 1（型定義の基盤強化）が名実ともに 100% 完了。定数管理や型ガードの各ページへの適用も徹底され、全 104 件のテストがパス。現在は Phase 2（サーバー駆動型 SSOT）に向けた準備中。

---

## 割り込みタスク: 当日勤怠データの修正制限
* [x] **[Frontend] UI 制御:** 詳細・承認ページへの案内表示追加とボタンの非活性化。
* [x] **[Backend] サーバーガード:** 保存・更新処理における当日データアクセスへの 403 ガード実装。
* [x] **[Test] テスト実装:** モデルの境界値ユニットテストと UI 振る舞い E2E テストの合格。
* [x] **[E2E] シナリオ完遂:** 昨日以前のデータを自動選別する修正・承認フローの完走。

---

## 0. ワークフロー의 目的 (Meta Rules for AI Agent)
本ドキュメントは、「Lara-Inertia-Attendance」プロジェクトにおける具体的な開発タスクと手順を定義する「唯一の正解ソース（Single Source of Truth）」である。AIエージェントは、タスクを実行する際、必ずこのワークフローに従うこと。

- **役割:** このドキュメントは、プロジェクトの「実行可能な命令セット」である。単なる読み物ではなく、一つずつ実行し、チェックを入れることで進捗を管理する対象として扱うこと。
- **原則:** チェックリストの項目は、必ず上から順に実行すること。未完了のタスクをスキップしてはならない。
- **完了定義:** 各タスクは、「実装」だけでなく、後述する「動作確認」と「プロセス記録」が完了して初めて「完了済み（[x]）」とみなされる。
- **割り込みタスクの扱い (Interrupt Handling):**
    - お客様からの新しいご指示や、予期せぬエラーが発生した場合、それを割り込みタスクとして最優先で扱うこと。
    - その際、まずこのドキュメントの「【現在進行中のタスク】」セクションを更新し、元のタスクを「保留」にして割り込みタスクを記録する。
    - 割り込みタスク完了後、元のタスクを再開すること。


## 1. ロードマップ (Refactoring Roadmap)

### Phase 1: 基盤再構築 (Infrastructure)
* [x] **プロジェクト作成:** Laravel 12 + Sail + MySQL 環境の構築。
* [x] **ドキュメント整備:** 開発ルールの策定とドキュメント移植。
* [x] **Inertia導入:** React + TypeScript + Vite 環境のセットアップ。
* [x] **認証基盤:** Laravel Breeze (React) のインストールと動作確認。
* [x] **Lint/Format:** ESLint, Prettier, PHP-CS-Fixer (Pint) の設定。

### Phase 2: データとモデルの移行 (Data & Auth)
* [x] **マイグレーション移植:** 旧プロジェクトからスキーマ定義を移植・最適化。
* [x] **モデル作成:** Eloquent モデルの作成と型定義。
* [x] **シーディング:** 開発用ダミーデータの生成。

### Phase 3: 一般ユーザー機能の実装 (User Features)
* [x] **打刻機能 (US006):** リアルタイム時計と打刻ロジックの構築。
* [x] **勤怠一覧 (US007):** 月次カレンダー表示とナビゲーション。
* [x] **勤怠詳細・修正申請 (US008):** 詳細表示と修正フォーム送信（保存処理、モダンUX化含む）。
* [x] **申請一覧 (US009):** 承認待ち・承認済みの確認画面（タブ切り替え）。

### Phase 4: 管理者機能の実装 (Admin Features)
* [x] **管理者認証 (US004, US005):** 管理者ログイン・ログアウト（管理者フラグ認可）。
* [x] **日次勤怠管理 (US010, US011):** 全ユーザーの日次一覧表示と直接修正（FN039: バリデーションを含む）。
* [x] **申請承認管理 (US014, US015):** 申請一覧の確認と承認アクション。
* [x] **スタッフ管理 (US012, US013):** スタッフ一覧、個人別月次勤怠、CSVエクスポート (FN045)。

### [緊急] バグ修正タスク (Bug Fixes)
* [x] **タイムゾーン修正:** サーバー・DB・アプリ設定を日本時間 (Asia/Tokyo) に統一。
* [x] **休憩時間計算修正:** 休憩時間がマイナスになる等のロジック不備を修正。
* [x] **合計時間計算修正:** 勤務合計時間が 0:00 になる問題を修正。

### Phase 5: メール認証と品質強化 (Refinement & Auth)
* [x] **メール認証 (FN011):** ユーザー登録時のメール確認フローの実装。
* [x] **UIアップグレード:** 日付選択 UI の Shadcn UI (Calendar/Popover) への置き換え。

### Phase 6: テストの実装と自動化 (Testing & Automation)
* [x] **[E2E] Playwright 導入:** 環境隔離（専用DB・サーバー）と最初のハッピーパス実装。
* [x] **[E2E] シナリオ網羅:** 全 9 件の機能・ワークフローテストの合格。
* [x] **[Unit] Vitest 導入:** 
    * [x] Vitest & Testing Library のセットアップ and 環境構築。
    * [x] DatePicker の単体テストによる健全性証明。
    * [x] **MonthPicker 検証:** パースロジックと年次ナビゲーションのテスト。
    * [x] **useCorrectionForm 検証:** 初期値変換ロジックと isAdmin による送信先切り替えのテスト。
    * [x] **CorrectionForm UI検証:** モード（閲覧/編集）に応じた表示制御のテスト。
    * [x] **AttendanceTable 検証:** ルート切り替えと動的リンク生成のテスト。
    * [x] 複雑なビジネスロジックや共通コンポーネントの網羅テスト。
* [x] **[Automation] GitHub Actions:** Lint, Featureテスト, E2Eテストの自動実行パイプライン構築。
* [ ] **README整備:** プロジェクト概要とセットアップ手順の最終化。


## 2. リファクタリング・ロードマップ (Score 60.0+ への挑戦)

### 🛡️ リファクタリングの鉄則 (Guiding Principles)
* **見た目を変えない:** リファクタリングの正解は「UIや挙動に変化がないこと」である。
* **回帰テストの徹底:** 変更のたびに `npm run test:unit` および `npx playwright test` を実行し、既存機能のデグレードがないことを機械的に保証する。
* **厳格な型チェック:** `npx tsc --noEmit` を実行し、TypeScript エラーが 0 であることを各タスクの完了条件とする。
* **原子的なコミット:** 影響範囲を抑えるため、「ページ単位」「型定義単位」など、可能な限り細かく刻んでコミットし、トラブル時の切り分けを容易にする。

### Phase 1: 型定義の基盤強化 (Quick Wins & Logic)
* [x] **PageProps 厳密化:** 一般ユーザー側・管理者側の全ページにおけるジェネリクス化と共有データの明示。
* [x] **utils.d.ts 新設:** `NonNullableFields<T>`, `PaginatedResponse<T>` 等の高度なユーティリティ型定義。
* [x] **Type Guard の導入:** `isUser`, `isAttendance` などの型ガード関数による `unknown` の安全な絞り込み（Grade S 対応）。
* [x] **定数管理の徹底:** マジックナンバーを排除し、`as const` + Union Types へ移行。


### Phase 2: サーバー駆動型 SSOT の確立
* [ ] **`spatie/laravel-data` 導入:** バックエンドでの Data Object 定義。
* [ ] **TypeScript 自動生成:** PHP モデル・Data Object から TS 型定義を自動出力する環境構築。
* [ ] **型チェーンの完成:** Service → Data → Inertia → Props の一貫した型安全性の確保。

### Phase 3: ランタイム安全性の確保 (Zod 統合)
* [ ] **スキーマ駆動開発:** `CorrectionForm` 等への Zod 導入と `z.infer` による型生成。
* [ ] **バリデーションの統合:** フロントエンド即時検証とバックエンド検証の役割分担。

### Phase 4: 抽象化とアーキテクチャの洗練
* [ ] **ジェネリクス・コンポーネント:** 汎用的なリスト部品やテーブルラッパーの抽出。
* [ ] **Pragmatic Atomic Design:** `Components/ui` (Shadcn) とドメイン特定コンポーネントの分離。
